#!/bin/bash

offset=$((2*1024*1024))
filesize=0
prog_req=(mkimage file fdtput)
tmp_files=()

function remove_tmp_files()
{
    for i in "${tmp_files[@]}"
    do
        rm -f "$i"
    done
}

function cleanup_and_return_err()
{
    rm -f $UBOOT_SOURCE $UBOOT_SCRIPT
    remove_tmp_files
    exit 1
}

function dt_mknode()
{
    local path=$1
    local addr=$2

    if test "$UBOOT_SOURCE" && test ! "$FIT"
    then
        echo "fdt mknod $path $addr" >> $UBOOT_SOURCE
    fi
}

# data_type is either
#   int
#   hex
#   str
#   str_a
function dt_set()
{
    local path=$1
    local var=$2
    local data_type=$3
    local data=$4


    if test "$UBOOT_SOURCE" && test ! "$FIT"
    then
        var=${var/\#/\\#}
        if test $data_type = "hex" || test $data_type = "int"
        then
            echo "fdt set $path $var <$data>" >> $UBOOT_SOURCE
        elif test $data_type = "str_a"
        then
            array=""
            for element in $data
            do
                array+=" \"$element\""
            done
            echo "fdt set $path $var $array" >> $UBOOT_SOURCE
        else
            echo "fdt set $path $var \"$data\"" >> $UBOOT_SOURCE
        fi
    fi

    if test $FDTEDIT
    then
        if test $data_type = "hex"
        then
            fdtput $FDTEDIT -p -t x $path $var $data
        elif test $data_type = "int"
        then
            fdtput $FDTEDIT -p -t i $path $var $data
        elif test $data_type = "str_a"
        then
            fdtput $FDTEDIT -p -t s $path $var $data
        else
            fdtput $FDTEDIT -p -t s $path $var "$data"
        fi
    fi
}

function add_device_tree_kernel()
{
    local path=$1
    local addr=$2
    local size=$3
    local bootargs=$4

    dt_mknode "$path" "module$addr"
    dt_set "$path/module$addr" "compatible" "str_a" "multiboot,kernel multiboot,module"
    dt_set "$path/module$addr" "reg" "hex"  "0x0 $addr 0x0 $(printf "0x%x" $size)"
    dt_set "$path/module$addr" "bootargs" "str" "$bootargs"
}


function add_device_tree_ramdisk()
{
    local path=$1
    local addr=$2
    local size=$3

    dt_mknode "$path"  "module$addr"
    dt_set "$path/module$addr" "compatible" "str_a" "multiboot,ramdisk multiboot,module"
    dt_set "$path/module$addr" "reg" "hex"  "0x0 $addr 0x0 $(printf "0x%x" $size)"
}


function add_device_tree_passthrough()
{
    local path=$1
    local addr=$2
    local size=$3

    dt_mknode "$path"  "module$addr"
    dt_set "$path/module$addr" "compatible" "str_a" "multiboot,device-tree multiboot,module"
    dt_set "$path/module$addr" "reg" "hex"  "0x0 $addr 0x0 $(printf "0x%x" $size)"
}

function xen_device_tree_editing()
{
    dt_set "/chosen" "#address-cells" "hex" "0x2"
    dt_set "/chosen" "#size-cells" "hex" "0x2"
    dt_set "/chosen" "xen,xen-bootargs" "str" "$XEN_CMD"
    dt_mknode "/chosen" "dom0"
    dt_set "/chosen/dom0" "compatible" "str_a" "xen,linux-zimage xen,multiboot-module multiboot,module"
    dt_set "/chosen/dom0" "reg" "hex" "0x0 $dom0_kernel_addr 0x0 $(printf "0x%x" $dom0_kernel_size)"
    dt_set "/chosen" "xen,dom0-bootargs" "str" "$DOM0_CMD"
    if test "$DOM0_RAMDISK" && test $ramdisk_addr != "-"
    then
        dt_mknode "/chosen" "dom0-ramdisk"
        dt_set "/chosen/dom0-ramdisk" "compatible" "str_a" "xen,linux-initrd xen,multiboot-module multiboot,module"
        dt_set "/chosen/dom0-ramdisk" "reg" "hex" "0x0 $ramdisk_addr 0x0 $(printf "0x%x" $ramdisk_size)"
    fi

    i=0
    while test $i -lt $NUM_DOMUS
    do
        if test "${DOMU_ROOTFS[$i]}" || test "${DOMU_NOBOOT[$i]}"
        then
            i=$(( $i + 1 ))
            continue
        fi
        dt_mknode "/chosen" "domU$i"
        dt_set "/chosen/domU$i" "compatible" "str" "xen,domain"
        dt_set "/chosen/domU$i" "#address-cells" "hex" "0x2"
        dt_set "/chosen/domU$i" "#size-cells" "hex" "0x2"
        dt_set "/chosen/domU$i" "memory" "int" "0 ${DOMU_MEM[$i]}"
        dt_set "/chosen/domU$i" "cpus" "int" "${DOMU_VCPUS[$i]}"
        dt_set "/chosen/domU$i" "vpl011" "hex" "0x1"
        add_device_tree_kernel "/chosen/domU$i" ${domU_kernel_addr[$i]} ${domU_kernel_size[$i]} "${DOMU_CMD[$i]}"
        if test "${domU_ramdisk_addr[$i]}"
        then
            add_device_tree_ramdisk "/chosen/domU$i" ${domU_ramdisk_addr[$i]} ${domU_ramdisk_size[$i]}
        fi
        if test "${domU_passthrough_dtb_addr[$i]}"
        then
            add_device_tree_passthrough "/chosen/domU$i" ${domU_passthrough_dtb_addr[$i]} ${domU_passthrough_dtb_size[$i]}
        fi
        i=$(( $i + 1 ))
    done
}

function linux_device_tree_editing()
{
    dt_set "/chosen" "bootargs" "str" "$LINUX_CMD"
    if test "$LINUX_RAMDISK"
    then
        local ramdisk_addr_end="$( printf "0x%x" $(( ramdisk_addr + ramdisk_size )) )"
        dt_set "/chosen" "linux,initrd-start" "hex" "$ramdisk_addr"
        dt_set "/chosen" "linux,initrd-end" "hex" "$ramdisk_addr_end"
    fi
}

function device_tree_editing()
{
    local device_tree_addr=$1

    if test $UBOOT_SOURCE
    then
        echo "fdt addr $device_tree_addr" >> $UBOOT_SOURCE
        echo "fdt resize 1024" >> $UBOOT_SOURCE

        if test $NUM_DT_OVERLAY && test $NUM_DT_OVERLAY -gt 0
        then
            i=0
            while test $i -lt $NUM_DT_OVERLAY
            do
                echo "fdt apply ${dt_overlay_addr[$i]}" >> $UBOOT_SOURCE
                i=$(( $i + 1 ))
            done
        fi
    fi

    if test "$os" = "xen"
    then
        xen_device_tree_editing
    else
        linux_device_tree_editing
    fi
}

function add_size()
{
    local filename=$1
    local size=`stat -L --printf="%s" $filename`
    memaddr=$(( $memaddr + $size + $offset - 1))
    memaddr=$(( $memaddr & ~($offset - 1) ))
    memaddr=`printf "0x%X\n" $memaddr`
    filesize=$size
}

function load_file()
{
    local filename=$1
    local fit_scr_name=$2

    local relative_path="$(realpath --relative-to=$PWD $filename)"

    if test "$FIT"
    then
        echo "imxtract \$fit_addr $fit_scr_name $memaddr" >> $UBOOT_SOURCE
    else
        echo "$LOAD_CMD $memaddr $relative_path" >> $UBOOT_SOURCE
    fi
    add_size $filename
}

function check_file_type()
{
    local filename=$1
    local type="$2"

    if [ ! -f $filename ]
    then
        echo "File $filename doesn't exist, exiting";
        cleanup_and_return_err
    fi

    # if file doesn't know what it is, it outputs data, so include that
    # since some executables aren't recongnized
    if [ "$type" = "executable" ]
    then
        type="executable\|data"
    # file in older distros (ex: RHEL 7.4) just output data for device
    # tree blobs
    elif [ "$type" = "Device Tree Blob" ]
    then
        type="Device Tree Blob\|data"
    fi

    file -L $filename | grep "$type" &> /dev/null
    if test $? != 0
    then
        echo Wrong file type "$filename". It should be "$type", exiting.
        cleanup_and_return_err
    fi
}

function check_compressed_file_type()
{
    local filename=$1
    local type="$2"

    if [ ! -f $filename ]
    then
        echo "File $filename doesn't exist, exiting";
        cleanup_and_return_err
    fi

    file -L $filename | grep "gzip compressed data" &> /dev/null
    if test $? == 0
    then
        local tmp=`mktemp`
        tmp_files+=($tmp)
        cat $filename | gunzip > $tmp
        filename=$tmp
    fi
    check_file_type $filename "$type"
}

function find_root_dev()
{

    local dev=${LOAD_CMD%:*}
    dev=${dev##* }
    local par=${LOAD_CMD#*:}

    if [ -z "$dev" ] || [ -z "$par" ]
    then
        echo "Could not parse device and partition."
        echo "Please make sure the load command is correct or manually set {DOM0/LINUX}_CMD in the config file."
        exit 1
    fi

    par=$((par + 1))

    if [[ $LOAD_CMD =~ mmc ]]
    then
        root_dev="/dev/mmcblk${dev}p${par}"
    elif [[ $LOAD_CMD =~ scsi ]]
    then
        # converts number to a scsi device character
        dev=$((dev + 97))
        dev=$(printf %x $dev)
        dev=$(printf "\x$dev")

        root_dev="/dev/sd${dev}${par}"
    else
        echo "Only mmc and scsi are supported for automatically setting the root partition."
        echo "Manually set {DOM0/LINUX}_CMD with the root device in the config file to bypass this."
        exit 1
    fi
}

function xen_config()
{
    if [ -z "$XEN_CMD" ]
    then
        XEN_CMD="console=dtuart dtuart=serial0 dom0_mem=1G dom0_max_vcpus=1 bootscrub=0 vwfi=native sched=null"
    fi

    if [ -z "$DOM0_CMD" ]
    then
        DOM0_CMD="console=hvc0 earlycon=xen earlyprintk=xen clk_ignore_unused"
    fi
    if [[ ! $DOM0_CMD =~ root= ]]
    then
        if test -z "$DOM0_ROOTFS"
        then
            DOM0_CMD="$DOM0_CMD root=/dev/ram0"
        else
            find_root_dev
            # $root_dev is set by find_root_dev
            DOM0_CMD="$DOM0_CMD root=$root_dev"
        fi
    fi
    i=0
    while test $i -lt $NUM_DOMUS
    do
        if test -z "${DOMU_MEM[$i]}"
        then
            DOMU_MEM[$i]=512
        fi
        DOMU_MEM[$i]=$((${DOMU_MEM[$i]} * 1024))
        if test -z "${DOMU_VCPUS[$i]}"
        then
            DOMU_VCPUS[$i]=1
        fi
        if test -z "${DOMU_CMD[$i]}"
        then
            DOMU_CMD[$i]="console=ttyAMA0"
        fi
        i=$(( $i + 1 ))
    done
}

function linux_config()
{
    if [ -z "$LINUX_CMD" ]
    then
        LINUX_CMD="earlycon console=ttyPS0,115200"
    fi

    if [[ ! $LINUX_CMD =~ root= ]]
    then
        if test -z "$LINUX_ROOTFS"
        then
            LINUX_CMD="$LINUX_CMD root=/dev/ram0"
        else
            find_root_dev
            # $root_dev is set by find_root_dev
            LINUX_CMD="$LINUX_CMD root=$root_dev"
        fi
    fi
}

xen_file_loading()
{
    check_compressed_file_type $DOM0_KERNEL "executable"
    dom0_kernel_addr=$memaddr
    load_file $DOM0_KERNEL "dom0_linux"
    dom0_kernel_size=$filesize

    if test "$DOM0_RAMDISK"
    then
        check_compressed_file_type $DOM0_RAMDISK "cpio archive"
        ramdisk_addr=$memaddr
        ramdisk_path=$DOM0_RAMDISK
        load_file "$DOM0_RAMDISK" "dom0_ramdisk"
        ramdisk_size=$filesize
    else
        ramdisk_addr="-"
    fi

    i=0
    while test $i -lt $NUM_DOMUS
    do
        if test "${DOMU_ROOTFS[$i]}" || test "${DOMU_NOBOOT[$i]}"
        then
            if test -z "${DOMU_NOBOOT[$i]}"
            then
                echo "Skipping DomU[$i]: cannot handle non-ramdisk rootfs for dom0less VMs."
            fi
            i=$(( $i + 1 ))
            continue
        fi
        check_compressed_file_type ${DOMU_KERNEL[$i]} "executable"
        domU_kernel_addr[$i]=$memaddr
        load_file ${DOMU_KERNEL[$i]} "domU${i}_kernel"
        domU_kernel_size[$i]=$filesize
        if test "${DOMU_RAMDISK[$i]}"
        then
            check_compressed_file_type ${DOMU_RAMDISK[$i]} "cpio archive"
            domU_ramdisk_addr[$i]=$memaddr
            load_file ${DOMU_RAMDISK[$i]} "domU${i}_ramdisk"
            domU_ramdisk_size[$i]=$filesize
        fi
        if test "${DOMU_PASSTHROUGH_DTB[$i]}"
        then
            check_compressed_file_type ${DOMU_PASSTHROUGH_DTB[$i]} "Device Tree Blob"
            domU_passthrough_dtb_addr[$i]=$memaddr
            load_file ${DOMU_PASSTHROUGH_DTB[$i]} "domU${i}_fdt"
            domU_passthrough_dtb_size[$i]=$filesize
        fi
        i=$(( $i + 1 ))
    done

    # secure boot on uboot expects the last PE image loaded to be the
    # signed secureboot image used
    check_compressed_file_type $XEN "executable"
    kernel_addr=$memaddr
    kernel_path=$XEN
    load_file "$XEN" "host_kernel"
}

linux_file_loading()
{
    check_compressed_file_type $LINUX "executable"
    kernel_addr=$memaddr
    kernel_path=$LINUX
    load_file "$LINUX" "host_kernel"

    if test "$LINUX_RAMDISK"
    then
        check_compressed_file_type $LINUX_RAMDISK "cpio archive"
        ramdisk_addr=$memaddr
        ramdisk_path=$LINUX_RAMDISK
        load_file "$LINUX_RAMDISK" "host_ramdisk"
        ramdisk_size=$filesize
    else
        ramdisk_addr="-"
    fi
}

bitstream_load_and_config()
{
    if test "$BITSTREAM"
    then
        check_file_type "$BITSTREAM" "BIT data"
        bitstream_addr=$memaddr
        load_file $BITSTREAM "fpga_bitstream"
        bitstream_size=$filesize
        if test "$UBOOT_SOURCE"
        then
            # we assume the FPGA device is 0 here
            echo "fpga load 0 $bitstream_addr $bitstream_size" >> "$UBOOT_SOURCE"
        fi
    fi
}

create_its_file_xen()
{
    if test "$ramdisk_addr" != "-"
    then
        load_files="\"dom0_linux\", \"dom0_ramdisk\""
    else
        load_files="\"dom0_linux\""
    fi
    # xen below
    cat >> "$its_file" <<- EOF
        dom0_linux {
            description = "dom0 linux kernel binary";
            data = /incbin/("$DOM0_KERNEL");
            type = "kernel";
            arch = "arm64";
            os = "linux";
            compression = "none";
            load = <$dom0_kernel_addr>;
            $fit_algo
        };
	EOF
    # domUs
    i=0
    while test $i -lt $NUM_DOMUS
    do
        if test "${DOMU_ROOTFS[$i]}" || test "${DOMU_NOBOOT[$i]}"
        then
            i=$(( $i + 1 ))
            continue
        fi
        load_files+=", \"domU${i}_kernel\""
        cat >> "$its_file" <<- EOF
        domU${i}_kernel {
            description = "domU${i} kernel binary";
            data = /incbin/("${DOMU_KERNEL[$i]}");
            type = "kernel";
            arch = "arm64";
            os = "linux";
            compression = "none";
            load = <${domU_kernel_addr[$i]}>;
            $fit_algo
        };
	EOF
        if test "${DOMU_RAMDISK[$i]}"
        then
            load_files+=", \"domU${i}_ramdisk\""
            cat >> "$its_file" <<- EOF
        domU${i}_ramdisk {
            description = "domU${i} ramdisk";
            data = /incbin/("${DOMU_RAMDISK[$i]}");
            type = "ramdisk";
            arch = "arm64";
            os = "linux";
            compression = "none";
            load = <${domU_ramdisk_addr[$i]}>;
            $fit_algo
        };
	EOF
        fi
        if test "${DOMU_PASSTHROUGH_DTB[$i]}"
        then
            load_files+=", \"domU${i}_fdt\""
            cat >> "$its_file" <<- EOF
        domU${i}_fdt {
            description = "domU${i} fdt";
            data = /incbin/("${DOMU_PASSTHROUGH_DTB[$i]}");
            type = "flat_dt";
            arch = "arm64";
            compression = "none";
            load = <${domU_passthrough_dtb_addr[$i]}>;
            $fit_algo
        };
	EOF
        fi
        i=$(( $i + 1 ))
    done
}

create_its_file()
{
    fdt_line="fdt = \"host_fdt\";"
    cat >> "$its_file" <<- EOF
/dts-v1/;
/ {
    description = "Configuration from Imagebuilder to load Xen/Linux";
    #address-cells = <1>;
    images {
        host_fdt {
            description = "$os fdt";
            data = /incbin/("$FDTEDIT");
            type = "flat_dt";
            arch = "arm64";
            compression = "none";
            load = <$device_tree_addr>;
            $fit_algo
        };
	EOF

    cat >> "$its_file" <<- EOF
        host_kernel {
            description = "$os kernel";
            data = /incbin/("$kernel_path");
            type = "kernel";
            arch = "arm64";
            os = "linux";
            compression = "none";
            load = <$kernel_addr>;
            entry = <$kernel_addr>;
            $fit_algo
        };
	EOF

    if test "$ramdisk_addr" != "-"
    then
        if test "$os" = "xen"
        then
            local rd_name="dom0"
        else
            local rd_name="host"
        fi
        cat >> "$its_file" <<- EOF
        ${rd_name}_ramdisk {
            description = "$rd_name ramdisk";
            data = /incbin/("$ramdisk_path");
            type = "ramdisk";
            arch = "arm64";
            os = "linux";
            compression = "none";
            load = <$ramdisk_addr>;
            $fit_algo
        };
	EOF
    fi

    if test "$os" = "xen"
    then
        create_its_file_xen
    fi

    if test $NUM_DT_OVERLAY && test $NUM_DT_OVERLAY -gt 0
    then
        fdt_line="fdt = \"host_fdt\""
        i=0
        while test $i -lt $NUM_DT_OVERLAY
        do
            cat >> "$its_file" <<- EOF
        host_fdto${i} {
            description = "$os fdt overlay ${i}";
            data = /incbin/("${DT_OVERLAY[$i]}");
            type = "flat_dt";
            arch = "arm64";
            compression = "none";
            load = <${dt_overlay_addr[$i]}>;
            $fit_algo
        };
	EOF
            fdt_line+=", \"host_fdto${i}\""
            i=$(( $i + 1 ))
        done
        fdt_line+=";"
    fi

    if test "$BITSTREAM"
    then
        local fpga_line="fpga = \"fpga_bitstream\";"
        cat >> "$its_file" <<- EOF
        fpga_bitstream {
            description = "FPGA bit stream";
            data = /incbin/("$BITSTREAM");
            type = "fpga";
            arch = "arm64";
            compression = "none";
            compatible = "u-boot,fpga-legacy";
            load = <$bitstream_addr>;
            $fit_algo
        };
	EOF
    fi

    # script for fit
    cat >> "$its_file" <<- EOF
        boot_scr {
            description = "imagebuilder's boot script";
            data = /incbin/("$UBOOT_SOURCE");
            type = "script";
            compression = "none";
            load = <$uboot_addr>;
            entry = <$uboot_addr>;
            $fit_algo
        };
	EOF
    # end images
    echo '    };' >> "$its_file"

    # config
    local ramdisk_line=""
    if test "$os" = "xen"
    then
        local loadables_line="loadables = $load_files;"
    elif test "$ramdisk_addr" != "-"
    then
        local ramdisk_line="ramdisk = \"host_ramdisk\";"
    fi
    cat >> "$its_file" <<- EOF
    configurations {
        default = "config";
        config {
            description = "Imagebuilder $os";
            kernel = "host_kernel";
            $fdt_line
            $ramdisk_line
            $fpga_line
            $loadables_line
        };
    };
	EOF
    # end
    echo '};' >> "$its_file"
}

function check_depends()
{
    for ((i=0; i<${#prog_req[@]}; i++))
    do
        if ! command -v ${prog_req[i]} > /dev/null
        then
            echo "Please install the needed program: ${prog_req[i]}."
            exit 1
        fi
    done
}

function print_help
{
    script=`basename "$0"`
    echo "usage:"
    echo "	$script -c CONFIG_FILE -d DIRECTORY [-t LOAD_CMD] [-o FILE] [-k KEY_DIR/HINT [-u U-BOOT_DTB]] [-e] [-f]"
    echo "	$script -h"
    echo "where:"
    echo "	CONFIG_FILE - configuration file"
    echo "	DIRECTORY - root directory where the files of CONFIG_FILE are located"
    echo "	LOAD_CMD can be:"
    echo "		sd - alias for \"load mmc 0:1\" for uboot load commands"
    echo "		scsi - alias for \"load scsi 0:1\" for uboot load commands"
    echo "		tftp - alias for \"tftpb\" for uboot load cammnds"
    echo "		< > - used for uboot load commands"
    echo "	FILE - output filename for the uboot script and its source, overrides option in CONFIG_FILE"
    echo "	KEY_DIR - key directory used for signing a fit image"
    echo "	HINT - the file name of the crt and key file minus the suffix (ex, hint.crt and hint.key)"
    echo "	U-BOOT_DTB - u-boot control dtb so that the public key gets added to it"
    echo "	-e - uses efiboot rather than booti"
    echo "	-f - enable generating a FIT image"
    echo "	-h - prints out the help message and exits "
    echo "Defaults:"
    echo "	CONFIG_FILE=$cfg_file, UBOOT_TYPE=\"LOAD_CMD\" env var, DIRECTORY=$uboot_dir"
    echo "Example:"
    echo "	$script -c ../config -d ./build42 -t \"scsi load 1:1\""
}

while getopts ":c:t:d:ho:k:u:ef" opt; do
    case ${opt} in
    t )
        case $OPTARG in
        scsi )
            load_opt="load scsi 0:1"
            ;;
        sd )
            load_opt="load mmc 0:1"
            ;;
        tftp )
            load_opt="tftpb"
            ;;
        * )
            load_opt="$OPTARG"
            ;;
        esac
        ;;
    c )
        cfg_file=$OPTARG
        ;;
    d )
        uboot_dir=$OPTARG
        ;;
    o )
        uboot_out_opt=$OPTARG
        ;;
    k )
        fits_keyd_opt=$OPTARG
        ;;
    u )
        fits_dtb_opt=$OPTARG
        ;;
    e )
        efi_opt=y
        ;;
    f )
        fit_opt=y
        ;;
    h )
        print_help
        exit 0
        ;;
    * )
        echo "Unknown option, see \"$0 -h\""
        exit 1
        ;;
    esac
done
shift $((OPTIND -1))

if test ! "$cfg_file" -o ! "$uboot_dir"
then
    echo "Undefined arguments, see \"$0 -h\""
    exit 1
fi

check_depends

source "$cfg_file"

# command line overrides
LOAD_CMD=${load_opt:-$LOAD_CMD}
EFI=${efi_opt:-$EFI}
FIT_ENC_KEY_DIR=${fits_keyd_opt:-$FIT_ENC_KEY_DIR}
FIT_ENC_UB_DTB=${fits_dtb_opt:-$FIT_ENC_UB_DTB}
if [ ! -z "$uboot_out_opt" ]
then
    UBOOT_SCRIPT="$uboot_out_opt".scr
    UBOOT_SOURCE="$uboot_out_opt".source
fi
if test "$fit_opt" && ! test "$FIT"
then
    FIT="${UBOOT_SOURCE%.source}.fit"
fi

if test ! "$LOAD_CMD"
then
    echo "LOAD_CMD not set, either specify it in the config or set it with the -t option"
    exit 1
fi

if test "$XEN"
then
    os="xen"
    xen_config
elif test "$LINUX"
then
    os="linux"
    linux_config
else
    echo "Neither a Xen or Linux kernel is specified, exiting"
    exit 1
fi

fit_algo=$'hash {\n                algo = "md5";\n            };'
if test "$FIT_ENC_KEY_DIR" || test "$FIT_ENC_UB_DTB"
then
    if ! test "$FIT_ENC_KEY_DIR" && test "$FIT_ENC_UB_DTB"
    then
        echo "if encryption, you need to specify the key directory"
        exit 1
    fi

    key_hint="${FIT_ENC_KEY_DIR##*/}"
    key_dir="${FIT_ENC_KEY_DIR%/*}/"

    fit_enc_opt="-r -k $key_dir"
    if test "$FIT_ENC_UB_DTB"
    then
        fit_enc_opt+=" -K $FIT_ENC_UB_DTB"
    fi
    fit_algo=$'signature {\n                algo = \"sha1,rsa2048\";\n                key-name-hint = \"'"$key_hint"$'\";\n};'
fi

# the cd is needed so that the relative paths will match once we use
# tftp or move the files to a partition
cd "$uboot_dir"

if test "$FIT"
then
    if ! test "$FDTEDIT"
    then
        FDTEDIT="${DEVICE_TREE%.dtb}-fit.dtb"
    fi
    its_file="${FIT%.fit}.its"
    rm -f "$its_file"
fi

if test $FDTEDIT
then
    rm -f "$FDTEDIT"
    cp "$DEVICE_TREE" "$FDTEDIT"

    if test "$NUM_DT_OVERLAY" && test "$NUM_DT_OVERLAY" -gt 0
    then
        i=0
        while test $i -lt "$NUM_DT_OVERLAY"
        do
            if [ ! -f "${DT_OVERLAY[$i]}" ]
            then
                echo "Can not find ${DT_OVERLAY[$i]}, exiting"
                cleanup_and_return_err
            fi
            fdtoverlay -i "$FDTEDIT" -o "$FDTEDIT" "${DT_OVERLAY[$i]}"
            if test "$?" -ne "0"
            then
                echo "Can add overlay ${DT_OVERLAY[$i]} to $FDTEDIT, exiting"
                cleanup_and_return_err
            fi
            i=$(( $i + 1 ))
        done
        NUM_DT_OVERLAY=0
    fi
fi

rm -f $UBOOT_SOURCE $UBOOT_SCRIPT

if test "$FIT"
then
    echo 'fit_addr=$fileaddr' >>  $UBOOT_SOURCE
fi

memaddr=$(( $MEMORY_START + $offset ))
# 12582912 is 0xc00000, 12MB
if test $memaddr -lt 12582912
then
    memaddr="12582912"
fi
memaddr=`printf "0x%X\n" $memaddr`
uboot_addr=$memaddr
# 2MB are enough for a uboot script
memaddr=$(( $memaddr + $offset ))
memaddr=`printf "0x%X\n" $memaddr`

if test "$os" = "xen"
then
    xen_file_loading
else
    linux_file_loading
fi

if test $NUM_DT_OVERLAY && test $NUM_DT_OVERLAY -gt 0
then
    i=0
    while test $i -lt $NUM_DT_OVERLAY
    do
        if [ ! -f "${DT_OVERLAY[$i]}" ]
        then
            echo "Can not find ${DT_OVERLAY[$i]}, exiting"
            cleanup_and_return_err
        fi
        check_file_type "${DT_OVERLAY[$i]}" "Device Tree Blob"
        dt_overlay_addr[$i]=$memaddr
        load_file "${DT_OVERLAY[$i]}" "host_fdto${i}"
        i=$(( $i + 1 ))
    done
fi

check_file_type $DEVICE_TREE "Device Tree Blob"
device_tree_addr=$memaddr
load_file $DEVICE_TREE "host_fdt"
bitstream_load_and_config  # bitstream is loaded last but used first
device_tree_editing $device_tree_addr

# disable device tree reloation
echo "setenv fdt_high 0xffffffffffffffff" >> $UBOOT_SOURCE
if test "$EFI" && test "$EFI" != "n" && test "$EFI" != "no" && test "$EFI" != "false"
then
    echo "bootefi $kernel_addr $device_tree_addr" >> $UBOOT_SOURCE
else
    echo "booti $kernel_addr - $device_tree_addr" >> $UBOOT_SOURCE
fi

if test "$FIT"
then
    create_its_file
    mkimage -q -f "$its_file" $fit_enc_opt "$FIT"
else
    mkimage -A arm64 -T script -C none -a $uboot_addr -e $uboot_addr -d $UBOOT_SOURCE "$UBOOT_SCRIPT" &> /dev/null
fi

remove_tmp_files

fit_addr="$(printf "0x%x" $memaddr)"

if test "$FIT"
then
    memaddr=$(( $MEMORY_END - 2 * ( $memaddr + $offset ) ))
else
    memaddr=$(( $MEMORY_END - $memaddr - $offset ))
fi
if test $memaddr -lt 0
then
    echo Error, not enough memory to load all binaries
    cleanup_and_return_err
fi

if test "$FIT"
then
    echo "Generated uboot FIT image $FIT, to be loaded at or after address $fit_addr:"
    echo "$LOAD_CMD $fit_addr $FIT; source $fit_addr:boot_scr"
else
    echo "Generated uboot script $UBOOT_SCRIPT, to be loaded at address $uboot_addr:"
    echo "$LOAD_CMD $uboot_addr $UBOOT_SCRIPT; source $uboot_addr"
fi
